# 김영한 자바 고급 1편

---

## 섹션 1, 2 학습 내용 요약

### 멀티태스킹

- 멀티태스킹은 동시에 여러 작업을 수행하는 것을 의미한다.
- 소프트웨어적 관점에서 코어 1개에서 여러 프로그램을 동시에 실행하는 것을 의미한다.

### 멀티프로세싱

- 멀티 프로세싱은 2개 이상의 코어를 사용하여 여러 작업을 동시에 처리하는 것을 의미한다.
- 멀티 프로세싱을 수행한다는 것은 곧 멀티 태스킹을 수행한다는 것과 같다.(1개의 코어가 여러 개의 일을 수행하므로)

### 프로세스

- 프로세스는 실행(Running)중인 프로그램의 인스턴스다.
- 각 프로세스는 독립적인 메모리 공간을 갖고 있다. 따라서 서로 간섭하지 못한다.
- 하나의 프로세스가 강제로 종료되어도 다른 프로세스는 영향을 받지 않는다.
- 프로세스의 메모리는 코드(실행할 프로그램의 코드가 저장되는 부분), 데이터 섹션(변수), 힙, 스택으로 구성된다.

### 스레드

- 프로세스는 하나 이상의 스레드를 반드시 포함한다. 스레드는 프로세스 내에서 실행되는 작업의 단위다.
- 한 프로세스의 코드, 데이터, 힙 섹션은 모든 스레드가 공유한다. 스택 섹션은 각 스레드마다 독립적으로 할당된다.
- 따라서 스레드는 공유 영역이 있기 때문에 하나의 스레드에서 발생한 문제가 전파될 수 있다.

---

## 섹션 3, 4, 5 학습 요약

### 자바 메모리 구조

![img.png](images/img.png)

- 메서드 영역 : 클래스 멤버 변수, 메서드 정보, static 변수 런타임 상수 풀 등이 저장된다.
- 스택 영역 : 지역 변수, 중간 연산 결과, 메서드 호출 정보 등이 저장된다.
- 힙 영역 : 객체와 배열이 생성되는 영역, 가비지 컬렉션 대상이다.

### Java Thread

- Java는 `Thread`라는 클래스를 제공한다.
- Thread의 실행은 `Thread.start()` 메서드를 호출하여 실행한다. `Thread.run()` 메서드를 직접 호출하면 안된다.
    - 왜냐하면 `run()` 메서드를 직접 호출하면 새로운 스레드가 생성되지 않고 현재 스레드에서 실행되기 때문이다.

### Runnable

- 스레드를 사용할 때는 `Thread`를 상속받는 것보다 `Runnable` 인터페이스를 구현하는 것이 좋다.
- `Runnable` 인터페이스를 구현하면 다른 클래스를 상속받을 수 있기 때문이다. 스레드와 실행할 작업이 분리된다.
- 여러 스레드가 동일한 `Runnable` 인스턴스를 공유할 수 있다.

### 스레드의 생명 주기

- NEW : 스레드가 생성되었지만 `start()` 메서드가 호출되지 않은 상태
- RUNNABLE : 실행 중 또는 실행 가능한 상태. 모든 RUNNABLE 상태의 스레드들이 항상 동시에 실행 중인 것은 아니다.
- BLOCKED : 동기화 블록에 의해 일시정지된 상태
- WAITING : 다른 스레드의 작업을 기다리는 상태. `wait()`, `join()`, `sleep()` 메서드가 호출되면 이 상태가 된다.
- TIMED_WAITING : 일정 시간 동안 기다리는 상태
- TERMINATED : 실행을 마친 상태

### 스레드 주요 메서드

- `sleep(ms)` : 주어진 시간(ms) 동안 스레드를 일시정지시킨다.
- `join(ms)` : 주어진 시간(ms) 동안 스레드가 종료될 때까지 기다린다.
- `interrupt()` : 스레드를 강제로 종료시킨다.
- `yield()` : 다른 스레드에게 실행을 양보한다.

---

## 섹션 6 학습 요약

### 메모리 가시성

- 각 스레드는 각각의 CPU 코어에서 실행된다. 물론 CPU 코어가 1개이면 번갈아서 실행된다.
- 그리고 스레드는 메인 메모리에 접근해서 데이터를 읽고 쓴다.
- 하지만 실제로는 성능상 이점을 누리기 위해 캐시 메모리를 사용한다.
- 캐시 메모리는 CPU 코어마다 존재한다. 물론 여러 코어가 공유하는 캐시 메모리도 있다.
- 따라서 스레드가 쓴 데이터가 캐시 메모리에만 저장되어 있으면 다른 스레드는 그 데이터를 읽을 수 없다.
- 캐시 메모리에 저장되었다고해서 메인 메모리에 곧바로 반영되지 않는다. 이것을 메모리 가시성 문제라고 한다.
  ![img_1.png](images/img_2.png)

### volatile 키워드

- `volatile` 키워드를 사용하면 메모리 가시성 문제를 해결할 수 있다.
- `volatile` 키워드를 사용하면 변수를 읽을 때마다 메인 메모리에서 읽어온다.
- 따라서 다른 스레드가 쓴 데이터를 즉시 읽을 수 있다.
- 하지만 캐시 메모리에 접근하지 않고 메인 메모리에 접근하기 때문에 성능상 저하가 발생한다.

### 캐시 메모리가 메인 메모리에 반영되고 메인 메모리가 캐시 메모리에 반영되는 시점?

- 알 수 없다. 환경에 따라 다 다를 수 있다.
- `Thread.sleep()`이 호출되었을 때 컨텍스트 스위칭이 되면서 주로 갱신되지만 보장할 수 없다.
- 반드시 `volatile` 키워드를 사용해야 한다.

### 자바 메모리 모델

- JMM(Java Memory Model)은 자바 프로그램이 실행되는 동안 메모리를 어떻게 사용하는지 정의한다.
- 자바 메모리 모델의 happens-before 관계에서는 A 작업이 B보다 먼저 수행될 경우 B 작업은 A 작업의 변경사항을 볼 수 있다.
- `volatile` 키워드를 사용하면 happens-before 관계를 만족한다.
- 이외에도 다양한 스레드 동기화 기법(syncronized, ReentrantLock, Semaphore, CountDownLatch 등)가 있다.

---

## 섹션 7, 8 학습 요약

### 공유 자원

- 같은 자원에 여러 스레드가 동시에 접근할 때 발생하는 동시성 문제를 주의해야 한다.
- 이때 여러 스레드가 접근하는 같은 자원을 공유 자원이라고 한다.

### 임계 영역

- 여러 스레드가 동시에 접근하면 데이터 불일치나 예상치 못한 동작이 발생할 수 있는 코드 조각을 의미한다.
- 출금의 예시로 들면 출금은 우선 잔액을 확인하고 지정한 액수만큼 차감하는데, 차감하는 부분이 임계 영역이다.
- 임계 영역을 안전하게 보호하는 방법의 대표적인 방법은 `synchronized` 키워드를 사용하는 것이다.

### synchronized

- 모든 객체(인스턴스)는 자신만의 lock을 가지고 있다. 이 lock을 모니터 락이라고 한다.
- `synchronized`는 한 번에 하나의 스레드만 실행하는 임계 영역을 만들 수 있다.
- 하지만 한 번에 하나의 스레드만 실행할 수 있다는 것은 장점이자 단점이다.
- 또한 무한 대기에 빠질 수 있으며, **락을 획득하는 순서를 보장하지 않는다. 따라서 데드락에 빠질 수 있다.**
- 따라서 꼭 필요한 부분에서만 사용하도록 하자

### LockSupport

- `LockSupport`는 스레드를 WAITING 상태로 변경한다. `park()` 메서드를 사용하면 된다.
- 이외에도 `parkNanos(ms)` 메서드가 있다.

### BLOCKED vs WAITING

- `BLOCKED`는 동기화 블록에 의해 일시정지된 상태이다.
- `WAITING`은 다른 스레드의 작업을 기다리는 상태이다.
- `BLOCKED` 상태는 인터럽트가 걸려도 대기 상태를 빠져나오지 못한다.
- 반면 `WAITING` 상태는 인터럽트가 걸리면 대기 상태를 빠져나올 수 있다.

### LockSupport의 한계

- 너무 저수준이다. 따라서 더 높은 수준의 동기화 기법이 필요한데, 이는 ReentrantLock이다.

### ReentrantLock

- JDK 1.5부터 제공되는 동기화 기법이다. synchronized의 무한 대기와 공정성 문제를 해결할 수 있다.
- `lock()` 메서드로 락을 획득하고 풀릴 때까지 대기한다. 인터럽트에 응답하지 않는다.
- `lockInterruptibly()` 메서드로 락을 획득하고 인터럽트에 응답한다. 락을 획득하지 못한 경우 대기하며 인터럽트가 걸리면 락을 풀고 예외를 던진다.
- `tryLock()` 메서드로 락을 획득하고 `true` 반환한다. 락을 획득하지 못한 경우 `false`를 반환한다.
- `unlock()` 메서드로 락을 해제한다. 락을 갖고 있는 스레드가 호출해야한다.

### 비공정 모드와 공정 모드

- **비공정 모드**는 `ReentrantLock`의 기본 모드이다. 락을 먼저 요청한 스레드가 락을 먼저 획득한다는 보장이 없다.
- 대기 중인 스레드 중 아무나 락을 획득할 수 있다. 이는 특정 스레드가 락을 빨리 획득할 수도, 장기간 획득하지 못할 수도 있음을 의미한다.
- 즉 기아 현상이 발생할 수 있다.
- 공정 모드는 락을 요청한 순서대로 스레드가 락을 획득할 수 있게 한다.
- 기아 현상을 방지할 수 있으나 락을 획득하는 속도가 느려질 수 있다.

---

### 섹션 9, 10 학습 요약

