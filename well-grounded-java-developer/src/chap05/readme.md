## 동시성 이론 입문

### 본인은 이미 동시성에 대해 알고있나?
- `Thread`, `Runnable` 같은 기본적인 매커니즘을 아는 것만으로는 유능한 자바 개발자라고 말할 수 없다.

### 하드웨어 먼저 알고가자
- 동시성 프로그래밍은 기본적으로 성능에 관한 것이다.
- 실행 주인 시스템의 성능이 블로킹으로도 잘 동작한다면 동시성 프로그래밍을 할 이유가 없다.
- 최신 컴퓨터 시스템에는 여러 개의 프로세싱 코어가 있으며 휴대폰에도 그렇다.
- 모든 자바 프로그램은 멀티스레드이며, 애플리켕션 스레드가 하나만 있는 프로그램도 마찬가지다.

### 자바의 스레드 모델
- 자바의 스레드 모델은 다음 두 가지 기본 개념을 기반으로 한다.
  - 공유되며 기본적으로 보이는 가변 상태
  - 운영체제에 의한 선점형 스레드 스케줄링
- 이런 아이디어의 가장 중요한 측면은 다음과 같다.
  - 객체는 프로세스 내의 모든 스레드 간에 쉽게 공유될 수 있다.
  - 객체에 대한 참조가 있는 모든 스레드에서 객체를 변경할 수 잇다.
  - 스레드 스케줄러는 언제든지 코어에 스레드를 할당하거나 제거할 수 있다.
  - 취약한 데이터를 보호하기 위해 객체를 잠글 수 있다. 이 기능은 `synchronized` 키워드로 제공된다.
- 자바는 각 객체에 대해 모니터락을 제공하는데 이는 잠금과 특정 조건이 참이될 때까지 기다릴 수 있는 능력을 결합한 것이다.

### 동시성 프로그래밍에서의 오버헤드 원인
- 모니터(잠금 및 조건 변수)
- 컨텍스트 스위칭 발생 횟수
- 스레드 수
- 스케줄링
- 메모리 위치
- 알고리즘 설계

### 자바 동기화와 잠금에 대한 몇 가지 사실

- 원시 자료형이 아닌 객체만 잠글 수 있다.
- 객체들의 배열을 잠가도 개별 객체는 잠기지 않는다.
- 내부 클래스의 동기화는 외부 클래스와 독립적이다.
- `synchronized` 메서드는 메서드 시그니처의 일부가 아니다. 따라서 인터페이스의 메서드 선언에 사용될 수 없다.
- 자바의 잠금은 재진입이 가능하다. 재진입이란, 한 스레드가 이미 보유한 잠금을 다시 얻을 수 있는 특성을 말한다.

### 완전히 동기화된 객체

다음 규칙을 따른다면 스레드 안전하다.
- 모든 필드는 모든 생성자에서 일관된 상태로 초기화된다.
- public 필드가 없다.
- 객체 인스턴스는 private 메서드에서 반환된 후에도 일관성이 보장된다.
- 모든 메서드는 유한한 시간 안에 종료된다는 것이 증명돼야 한다.
- 모든 메서드는 동기화돼야 한다.
- 어떤 메서드도 불일치한 상태에서 다른 인스턴스의 메서드를 호출하지 않는다.
- 어떤 메서드도 불일치한 상태에서 현재 인스턴스의 비공개 메서드를 호출하지 않는다.

### volatile 키워드

- 자바는 초창기부터 `volatile` 키워드를 제공했다.
- `volatile` 키워드가 선언된 필드는 스레드가 사용하기 전에 항상 메인 메모리에서 다시 읽는다.
- 그리고 스레드가 쓴 값은 모두 메인 메모리로 플러시된다.
- `volatile`의 핵심은 메모리 위치에 대해 하나의 작업만 허용하며 이 작업은 즉시 메모리에 플러시 된다.
- 단일 읽기 또는 단일 쓰기는 가능하지만 그 이상은 불가능하다. 가령 ++, -- 연산은 불가능하다.
- `volatile`은 잠금을 사용하지 않기 때문에 교착상태를 유발할 수 없다.

### 스레드 안전성과 불변 객체

동시성 스타일로 프로그래밍할 때 안전하게 공유해야 하는 데이터를 처리하는 유용한 기법 중 하나는 불변 객체를 활용하는 것이다.  
불변 객체는 상태가 없거나 `final` 필드만 있는 객체다. 이 객체는 상태가 변경될 수 없어 일관되지 않은 상태가 될 수 없기 때문에 항상 안전하다.  
한 가지 문제점은 특정 객체를 초기화하는 데 필요한 모든 값을 생성자에 전달해야 한다는 것이다.

이를 해결하려면 팩토리 메서드를 대신 사용하는 방법을 고려할 수 있다. 팩토리 메서드는 일반적으로 `protected` 또는 `private` 생성자를 사용한다.  



